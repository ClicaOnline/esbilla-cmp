rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // ============================================

    function isAuthenticated() {
      return request.auth != null;
    }

    function userDocExists() {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function getUserRole() {
      // Si el documento del usuario no existe (onboarding), retornar null
      if (!userDocExists()) return null;
      let userData = getUserData();
      // Priorizar globalRole (nuevo schema), fallback a role (legacy)
      return userData.globalRole != null ? userData.globalRole : userData.role;
    }

    function isAdmin() {
      let role = getUserRole();
      return isAuthenticated() && role != null && role in ['admin', 'superadmin', 'superuser'];
    }

    function isSuperAdmin() {
      // Incluye 'admin' para compatibilidad con usuarios legacy
      let role = getUserRole();
      return isAuthenticated() && role != null && role in ['admin', 'superadmin', 'superuser'];
    }

    function isAuthorized() {
      let role = getUserRole();
      return isAuthenticated() && role != null && role in ['viewer', 'admin', 'superadmin', 'superuser'];
    }

    // Multi-tenant: verificar acceso a sitio específico
    function hasSiteAccess(siteId) {
      if (!userDocExists()) return false;
      let userData = getUserData();
      return userData.role in ['admin', 'superadmin', 'superuser']
             || (userData.siteAccess != null && siteId in userData.siteAccess);
    }

    function hasSiteAdminAccess(siteId) {
      if (!userDocExists()) return false;
      let userData = getUserData();
      return userData.role in ['admin', 'superadmin', 'superuser']
             || (userData.siteAccess != null
                 && siteId in userData.siteAccess
                 && userData.siteAccess[siteId].role in ['owner', 'admin']);
    }

    // Multi-distribuidor: verificar acceso como distribuidor a una organización
    function hasDistributorAccess(orgId) {
      if (!userDocExists()) return false;
      let userData = getUserData();
      return userData.role in ['admin', 'superadmin', 'superuser']
             || (userData.distributorAccess != null && orgId in userData.distributorAccess);
    }

    // Verificar si el usuario tiene algún tipo de acceso a una organización
    function hasAnyOrgAccess(orgId) {
      if (!userDocExists()) return false;
      let userData = getUserData();
      return userData.role in ['admin', 'superadmin', 'superuser']
             || (userData.orgAccess != null && orgId in userData.orgAccess)
             || (userData.distributorAccess != null && orgId in userData.distributorAccess);
    }

    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow read: if isAdmin();

      allow create: if isAuthenticated() && request.auth.uid == userId
                    && (request.resource.data.role == 'pending' || request.resource.data.globalRole == 'pending');

      allow update: if isAuthenticated() && request.auth.uid == userId
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastLogin', 'onboardingCompleted']);

      allow update: if isAdmin() && request.auth.uid != userId;
      allow delete: if isSuperAdmin();
    }

    // ============================================
    // SITES COLLECTION (Multi-tenant)
    // ============================================
    match /sites/{siteId} {
      // Lectura: admin, acceso directo al sitio, o distribuidor de la org del sitio
      allow read: if isAdmin()
                  || (isAuthorized() && hasSiteAccess(siteId))
                  || (isAuthenticated() && resource.data.organizationId != null
                      && hasDistributorAccess(resource.data.organizationId));

      // Creación: admin, o durante onboarding
      allow create: if isAdmin();

      // Permitir crear sitio durante onboarding
      // El usuario autenticado puede crear sitios si es createdBy
      allow create: if isAuthenticated()
                    && request.resource.data.createdBy == request.auth.uid;

      // Actualización: admin, site_admin, o distributor_admin/distributor_manager
      allow update: if isAdmin()
                    || hasSiteAdminAccess(siteId)
                    || (isAuthenticated() && resource.data.organizationId != null
                        && getUserData().distributorAccess != null
                        && resource.data.organizationId in getUserData().distributorAccess
                        && getUserData().distributorAccess[resource.data.organizationId].role in ['distributor_admin', 'distributor_manager']);

      allow delete: if isSuperAdmin();
    }

    // ============================================
    // CONSENTS COLLECTION (GDPR-COMPLIANT + MULTI-DISTRIBUIDOR)
    // ============================================
    // Soporta DOS flujos de creación:
    // 1. API Backend (Admin SDK) - bypasea estas reglas
    // 2. SDK Directo - con validación de campos obligatorios
    //
    // CAMPOS OBLIGATORIOS para escritura directa desde SDK:
    // - user_hash: string (identificador anónimo)
    // - domain: string (dominio origen)
    // - distributorId: string (ID del distribuidor)
    // - timestamp: debe ser igual a request.time (previene manipulación)
    //
    // CAMPOS LEGACY (API Backend):
    // - siteId, userHash, choices, createdAt, expiresAt
    // ============================================
    match /consents/{consentId} {
      // CREACIÓN: SDK puede crear con validación de campos
      allow create: if request.resource.data.keys().hasAll(['user_hash', 'domain', 'distributorId', 'timestamp'])
                    && request.resource.data.timestamp == request.time;

      // LECTURA: Múltiples criterios de acceso
      allow read: if isAdmin()
                  // Opción 1: Usuario autenticado del mismo distribuidor
                  || (isAuthenticated() && hasDistributorAccess(resource.data.distributorId))
                  // Opción 2: Usuario con acceso al sitio (legacy)
                  || (isAuthorized() && resource.data.siteId != null && hasSiteAccess(resource.data.siteId))
                  // Opción 3: Usuario final consultando su propio rastro (transparencia GDPR)
                  || (request.auth != null
                      && request.auth.token.user_hash != null
                      && resource.data.user_hash == request.auth.token.user_hash);

      // INMUTABILIDAD: Los registros de consentimiento no se pueden modificar ni eliminar
      // Esto garantiza el audit trail requerido por GDPR
      // La eliminación se hace automáticamente vía TTL de Firestore (3 años)
      allow update: if false;
      allow delete: if false;
    }

    // ============================================
    // CONFIG COLLECTION (Configuración de banners)
    // ============================================
    // Lectura pública: El SDK necesita leer textos y colores del banner
    // Escritura restringida: Solo admins del distribuidor
    match /config/{configId} {
      allow read: if true; // SDK necesita acceso público
      allow write: if isAdmin()
                   || (isAuthenticated() && hasDistributorAccess(resource.data.distributorId));
    }

    // ============================================
    // DISTRIBUTORS COLLECTION (Gestión de distribuidores)
    // ============================================
    match /distributors/{distributorId} {
      allow read: if isAuthenticated() && hasDistributorAccess(distributorId);
      allow write: if isSuperAdmin()
                   || (isAuthenticated() && hasDistributorAccess(distributorId)
                       && getUserData().distributorRole == 'admin');
    }

    // ============================================
    // DAILY STATS COLLECTION (Estadísticas agregadas)
    // ============================================
    match /dailyStats/{statsId} {
      allow read: if isAdmin()
                  || (isAuthorized() && hasSiteAccess(resource.data.siteId))
                  || (isAuthenticated() && hasDistributorAccess(resource.data.distributorId));

      // Stats se crean/actualizan vía Cloud Functions o Admin SDK
      allow write: if false;
    }

    // ============================================
    // ORGANIZATIONS COLLECTION (Modelo SaaS)
    // ============================================
    match /organizations/{orgId} {
      // Superadmin: acceso total
      allow read, write: if isSuperAdmin();

      // Lectura: org_owner, org_admin, org_viewer o distribuidor
      allow read: if hasAnyOrgAccess(orgId);

      // Escritura: org_owner o distributor_admin
      allow update: if isAuthenticated() && (
        (getUserData().orgAccess != null &&
         orgId in getUserData().orgAccess &&
         getUserData().orgAccess[orgId].role == 'org_owner') ||
        (getUserData().distributorAccess != null &&
         orgId in getUserData().distributorAccess &&
         getUserData().distributorAccess[orgId].role == 'distributor_admin')
      );

      // Permitir crear organización durante onboarding
      // El usuario autenticado puede crear su primera organización
      allow create: if isAuthenticated()
                    && request.resource.data.createdBy == request.auth.uid;
    }

    // ============================================
    // INVITATIONS COLLECTION (Sistema de invitaciones)
    // ============================================
    match /invitations/{invitationId} {
      // Leer: invitado por email o quien invitó o admin
      allow read: if isAuthenticated() && (
        resource.data.email == request.auth.token.email ||
        resource.data.invitedBy == request.auth.uid ||
        isSuperAdmin()
      );

      // Crear: admins, org_owner/org_admin, o distributor_admin/distributor_manager
      allow create: if isAuthenticated() && (
        isSuperAdmin() ||
        (getUserData().orgAccess != null &&
         request.resource.data.organizationId in getUserData().orgAccess &&
         getUserData().orgAccess[request.resource.data.organizationId].role in ['org_owner', 'org_admin']) ||
        (getUserData().distributorAccess != null &&
         request.resource.data.organizationId in getUserData().distributorAccess &&
         getUserData().distributorAccess[request.resource.data.organizationId].role in ['distributor_admin', 'distributor_manager'])
      );

      // Actualizar: solo el invitado (para aceptar) o quien invitó (para revocar)
      allow update: if isAuthenticated() && (
        request.auth.token.email == resource.data.email ||
        request.auth.uid == resource.data.invitedBy ||
        isSuperAdmin()
      );

      // No permitir eliminar invitaciones (audit trail)
      allow delete: if false;
    }

    // ============================================
    // WAITING LIST COLLECTION (Lista de espera SaaS)
    // ============================================
    match /waitingList/{entryId} {
      // Leer: solo superadmins
      allow read: if isSuperAdmin();

      // Crear: público (desde landing page)
      allow create: if true;

      // Actualizar: solo superadmins (para cambiar estado, notas, etc.)
      allow update: if isSuperAdmin();

      // Eliminar: solo superadmins
      allow delete: if isSuperAdmin();
    }

    // ============================================
    // SUPPORT TICKETS COLLECTION (Tickets de soporte)
    // ============================================
    match /supportTickets/{ticketId} {
      // Leer: el creador del ticket o superadmin (futuro: support team)
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isSuperAdmin()
        // TODO: || isSupportTeam() para usuarios con rol de soporte
      );

      // Crear: cualquier usuario autenticado
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.status == 'open';

      // Actualizar: solo superadmin (futuro: support team o ticket owner para añadir comentarios)
      allow update: if isSuperAdmin();
      // TODO: Permitir al owner añadir comentarios pero no cambiar status/priority

      // Eliminar: solo superadmin
      allow delete: if isSuperAdmin();
    }
  }
}
